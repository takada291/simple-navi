<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simple-navi v2.2</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: sans-serif; margin: 10px; background-color: #f0f4f8; color: #333; -webkit-tap-highlight-color: transparent; }
        .card { background: white; padding: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); max-width: 600px; margin: auto; }
        h1 { font-size: 1.1rem; margin: 0 0 10px 0; color: #004a99; text-align: center; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        p { font-size: 0.8rem; text-align: center; margin: 5px 0; }
        
        .nav-panel { background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px; padding: 15px; margin-bottom: 15px; text-align: center; }
        .nav-target-input { display: flex; gap: 5px; margin-bottom: 5px; }
        .nav-target-input input { width: 50%; padding: 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 0.9rem; }
        
        .arrow-container { font-size: 4rem; margin: 10px 0; transition: transform 0.1s linear; display: inline-block; }
        .distance-display { font-size: 1.5rem; font-weight: bold; color: #d32f2f; }
        .compass-info { font-size: 0.8rem; color: #666; margin-bottom: 5px; background: #fff; border-radius: 5px; padding: 2px; }
        
        .display { background: #333; color: #0f0; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-family: monospace; font-size: 0.85rem; }
        .display div { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .display .val { font-weight: bold; color: #fff; }
        
        button { width: 100%; padding: 14px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 1rem; margin-bottom: 8px; transition: background 0.3s; }
        
        /* GPSボタンのアニメーション追加 */
        .btn-gps { background: #007bff; color: white; }
        .btn-gps.tracking { background: #dc3545; animation: pulse 1.5s infinite; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        .btn-map { background: #ff9800; color: white; margin-bottom: 5px; }
        .btn-compass { background: #28a745; color: white; }
        
        /* データ消去ボタン */
        .btn-clear { background: #fff; color: #d32f2f; border: 1px solid #d32f2f; font-size: 0.9rem; padding: 10px; margin-top: 5px; }

        #map { height: 350px; width: 100%; border-radius: 8px; margin-bottom: 15px; display: none; border: 1px solid #ccc; }
        
        /* ステータス表示エリア */
        #status { font-size: 0.8rem; color: #d32f2f; text-align: center; margin-bottom: 10px; font-weight: bold; min-height: 1.2em; }
        
        .system-box { background: #eee; padding: 10px; border-radius: 8px; font-size: 0.8rem; margin-bottom: 10px; }
        select { width: 100%; padding: 8px; margin-top: 5px; border-radius: 4px; }
        
        .input-label { font-size: 0.75rem; color: #004a99; text-align: left; font-weight: bold; margin-top: 5px; margin-bottom: 2px; }
    </style>
</head>
<body>

<div class="card">
    <h1>簡易ナビv2.2</h1>
    <p>事前に調査箇所周辺の地図を閲覧して下さい。地図データが保存されます。</p>
    
    <div id="status">待機中</div>

    <button class="btn-compass" id="btnCompass">コンパスを有効にする</button>

    <div class="nav-panel">
        <div class="compass-info" id="compassDisplay">方位計測：オフ</div>
        
        <div class="input-label">目標 X / Y (m)</div>
        <div class="nav-target-input">
            <input type="number" id="targetX" placeholder="目標 X (北)" step="0.001">
            <input type="number" id="targetY" placeholder="目標 Y (東)" step="0.001">
        </div>

        <div class="input-label">目標 緯度 / 経度 (度単位かつ少数6位まで)</div>
        <div class="nav-target-input">
            <input type="number" id="targetLat" placeholder="目標緯度 (36.xxx)" step="0.000001">
            <input type="number" id="targetLon" placeholder="目標経度 (136.xxx)" step="0.000001">
        </div>

        <div id="navResult">
            <div class="arrow-container" id="arrow">↑</div>
            <div class="distance-display"><span id="distVal">---</span> m</div>
        </div>
    </div>

    <div class="system-box">
        座標系の選択:
        <select id="systemSelect"></select>
    </div>      
    
    <button class="btn-gps" id="btnGps">現在地を連続して取得（開始）</button>

    <div id="map"></div>

    <div class="display">
        <div><span>現在 X (北):</span> <span class="val" id="posX">---</span> m</div>
        <div><span>現在 Y (東):</span> <span class="val" id="posY">---</span> m</div>
        <div style="font-size: 0.7rem; color: #aaa; margin-top:5px;">系: <span id="sysDisplay">6</span>系 / 緯度:<span id="lat">--</span> 経度:<span id="lon">--</span></div>
    </div>
    
    <button class="btn-map" id="btnMap">地図を表示（現在地；青、目標地；赤）</button>
    <button class="btn-clear" id="btnClearTrace">取得した軌跡データを消去</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // --- 定数・変数 ---
    const SYSTEM_ORIGINS = {
        1:[33,129.5], 2:[33,131], 3:[36,132.166666666], 4:[33,133.5], 5:[33,134.333333333],
        6:[36,136], 7:[36,137.166666666], 8:[36,138.5], 9:[36,139.833333333], 10:[40,140.833333333],
        11:[40,142.833333333], 12:[44,142.25], 13:[44,143.333333333], 14:[44,145.833333333],
        15:[26,124], 16:[26,127], 17:[26,131], 18:[20,136], 19:[26,154]
    };

    const GPS_INTERVAL = 15000; // 15秒間隔
    const STORAGE_KEY_TRACE = 'simpleNaviTraceData'; // 簡易ナビ用の軌跡保存キー

    let currentRaw = null;
    let deviceHeading = 0; 
    let targetAngle = 0;   
    let map = null, currentMarker = null, targetMarker = null, tracePolyline = null;
    
    // 連続取得用変数
    let isTracking = false;
    let trackingIntervalId = null;

    // --- 1. 座標系セレクトボックス生成 ---
    const sysSelect = document.getElementById('systemSelect');
    for (let i = 1; i <= 19; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.innerText = `第 ${i} 系 ${i===6 ? '(福井等)' : ''}`;
        if (i === 6) opt.selected = true;
        sysSelect.appendChild(opt);
    }

    // --- 2. 角度・座標計算 ---
    function updateNavigation() {
        const tx = parseFloat(document.getElementById('targetX').value);
        const ty = parseFloat(document.getElementById('targetY').value);
        if (isNaN(tx) || isNaN(ty) || !currentRaw || !currentRaw.x) return;

        const dx = tx - currentRaw.x;
        const dy = ty - currentRaw.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        document.getElementById('distVal').innerText = dist.toFixed(1);
        targetAngle = Math.atan2(dy, dx) * 180 / Math.PI;
        renderArrow();
    }

    function renderArrow() {
        const rotateDeg = targetAngle - deviceHeading;
        document.getElementById('arrow').style.transform = `rotate(${rotateDeg}deg)`;
    }

    // --- 入力連動ロジック (LatLon <-> XY) ---
    function syncFromLatLon() {
        const tLat = parseFloat(document.getElementById('targetLat').value);
        const tLon = parseFloat(document.getElementById('targetLon').value);
        const sysId = document.getElementById('systemSelect').value;

        if (!isNaN(tLat) && !isNaN(tLon)) {
            const res = convert(tLat, tLon, sysId);
            document.getElementById('targetX').value = res.x.toFixed(3);
            document.getElementById('targetY').value = res.y.toFixed(3);
            updateNavigation();
        }
    }

    function syncFromXY() {
        const tx = parseFloat(document.getElementById('targetX').value);
        const ty = parseFloat(document.getElementById('targetY').value);
        const sysId = document.getElementById('systemSelect').value;

        if (!isNaN(tx) && !isNaN(ty)) {
            const res = reverseConvert(tx, ty, sysId);
            document.getElementById('targetLat').value = res[0].toFixed(6);
            document.getElementById('targetLon').value = res[1].toFixed(6);
            updateNavigation();
        }
    }

    // --- 3. コンパス制御 ---
    function initCompass() {
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        if (isIOS && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        document.getElementById('btnCompass').style.display = 'none';
                    }
                }).catch(err => alert("コンパス許可エラー: " + err));
        } else {
            window.addEventListener('deviceorientationabsolute', handleOrientation, true);
            window.addEventListener('deviceorientation', handleOrientation, true);
            document.getElementById('btnCompass').style.display = 'none';
        }
    }

    let compassTimer = setTimeout(() => {
        const display = document.getElementById('compassDisplay');
        if (display && display.innerText === "方位計測：オフ") {
            display.innerText = "⚠️電子コンパス非対応→端末上部を北に向けて下さい";
            display.style.color = "red";
            deviceHeading = 0;
            renderArrow();
        }
    }, 4000);

    function handleOrientation(event) {
        let heading = null;
        if (event.webkitCompassHeading !== undefined) {
            heading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
            heading = 360 - event.alpha;
        }

        if (heading !== null) {
            clearTimeout(compassTimer);
            deviceHeading = heading;
            const display = document.getElementById('compassDisplay');
            display.innerText = `方位：${Math.round(heading)}° (スマホの向き)`;
            display.style.color = "#666";
            renderArrow();
        }
    }

    // --- 4. GPS位置情報 (連続取得対応) ---
    // GPSボタンクリック時のトグル処理
    function toggleTracking() {
        const btn = document.getElementById('btnGps');
        const status = document.getElementById('status');

        if (isTracking) {
            // 停止処理
            clearInterval(trackingIntervalId);
            isTracking = false;
            btn.innerHTML = "現在地を連続して取得（開始）";
            btn.classList.remove('tracking');
            status.innerText = "一時停止中";
            status.style.color = "#666";
        } else {
            // 開始処理
            isTracking = true;
            btn.innerHTML = "停止する（連続記録中）";
            btn.classList.add('tracking');
            status.innerText = "GPS探索中...";
            status.style.color = "#dc3545";
            
            // 初回即時実行
            getLocation();
            
            // 定期実行設定
            trackingIntervalId = setInterval(getLocation, GPS_INTERVAL);
        }
    }

    function getLocation() {
        const status = document.getElementById('status');
        const sysId = document.getElementById('systemSelect').value;
        
        // 連続取得中はステータス表示を少し変える
        if(!isTracking) {
            status.innerText = "GPS取得中...";
            status.style.color = "#007bff";
        }

        navigator.geolocation.getCurrentPosition(
            pos => {
                const nowTime = new Date().toLocaleTimeString();
                status.innerText = isTracking ? `更新完了 (${nowTime})` : "更新完了";
                status.style.color = "#28a745";
                
                currentRaw = { lat: pos.coords.latitude, lon: pos.coords.longitude };
                const res = convert(currentRaw.lat, currentRaw.lon, sysId);
                currentRaw.x = res.x; currentRaw.y = res.y;

                document.getElementById('lat').innerText = currentRaw.lat.toFixed(5);
                document.getElementById('lon').innerText = currentRaw.lon.toFixed(5);
                document.getElementById('posX').innerText = res.x.toFixed(3);
                document.getElementById('posY').innerText = res.y.toFixed(3);
                document.getElementById('sysDisplay').innerText = sysId;
                
                updateNavigation(); // 距離・方向の更新
                saveTrace(currentRaw.lat, currentRaw.lon); // 軌跡の保存
                
                // 地図が開いていれば更新
                if(document.getElementById('map').style.display === 'block') {
                    showMap(false); // false = 地図の強制リセット（setView）はしない
                }
            },
            err => { 
                status.innerText = "GPSエラー: " + err.message; 
                status.style.color = "#d32f2f";
                // エラーが出ても連続取得は止めない（山間部などでの瞬断を考慮）
            },
            { enableHighAccuracy: true, timeout: 20000, maximumAge: 0 }
        );
    }

    // 軌跡保存
    function saveTrace(lat, lon) {
        const trace = JSON.parse(localStorage.getItem(STORAGE_KEY_TRACE) || "[]");
        // 直近のデータと全く同じなら保存しない（重複回避）
        if (trace.length > 0) {
            const last = trace[trace.length - 1];
            if (last[0] === lat && last[1] === lon) return;
        }
        trace.push([lat, lon]);
        localStorage.setItem(STORAGE_KEY_TRACE, JSON.stringify(trace));
    }

    // 軌跡消去
    function clearTrace() {
        if(confirm("保存されている移動の軌跡データを消去しますか？\n（目標地点の設定は消えません）")) {
            localStorage.removeItem(STORAGE_KEY_TRACE);
            if(map && tracePolyline) {
                map.removeLayer(tracePolyline);
                tracePolyline = null;
            }
            alert("軌跡を消去しました。");
        }
    }

    // 座標変換ロジック
    function convert(lat, lon, sysId) {
        const origin = SYSTEM_ORIGINS[sysId];
        const phi0 = origin[0] * Math.PI / 180;
        const lam0 = origin[1] * Math.PI / 180;
        const phi = lat * Math.PI / 180;
        const lam = lon * Math.PI / 180;
        const a = 6378137.0, f = 1/298.257222101, m0 = 0.9999;
        const e2 = f*(2-f), n = f/(2-f);
        const ap = (a/(1+n))*(1 + (n**2)/4 + (n**4)/64);
        const beta = [0, (1/2)*n-(2/3)*(n**2)+(5/16)*(n**3), (13/48)*(n**2)-(3/5)*(n**3), (61/240)*(n**3)];
        const dl = lam - lam0;
        const t = Math.sinh(Math.atanh(Math.sin(phi)) - (2*Math.sqrt(n)/(1+n))*Math.atanh((2*Math.sqrt(n)/(1+n))*Math.sin(phi)));
        const xip = Math.atan(t / Math.cos(dl)), etap = Math.atanh(Math.sin(dl) / Math.sqrt(1 + t**2));
        let xi = xip, eta = etap;
        for(let j=1; j<=3; j++) {
            xi += beta[j]*Math.sin(2*j*xip)*Math.cosh(2*j*etap);
            eta += beta[j]*Math.cos(2*j*xip)*Math.sinh(2*j*etap);
        }
        const s = (p) => {
            const A = 1 + (3/4)*e2 + (45/64)*(e2**2) + (175/256)*(e2**3);
            const B = (3/4)*e2 + (15/16)*(e2**2) + (525/512)*(e2**3);
            const C = (15/64)*(e2**2) + (105/256)*(e2**3);
            return a*(1-e2)*(A*p - (B/2)*Math.sin(2*p) + (C/4)*Math.sin(4*p));
        };
        return { x: m0*ap*xi - m0*s(phi0), y: m0*ap*eta };
    }

    function reverseConvert(x, y, sysId) {
        const origin = SYSTEM_ORIGINS[sysId];
        const phi0 = origin[0] * Math.PI / 180;
        const lam0 = origin[1] * Math.PI / 180;
        const a = 6378137.0, f = 1/298.257222101, m0 = 0.9999;
        const e2 = f*(2-f), n = f/(2-f);
        const ap = (a/(1+n))*(1 + (n**2)/4 + (n**4)/64);
        const s0 = ((p) => {
            const A = 1 + (3/4)*e2 + (45/64)*(e2**2) + (175/256)*(e2**3);
            const B = (3/4)*e2 + (15/16)*(e2**2) + (525/512)*(e2**3);
            const C = (15/64)*(e2**2) + (105/256)*(e2**3);
            return a*(1-e2)*(A*p - (B/2)*Math.sin(2*p) + (C/4)*Math.sin(4*p));
        })(phi0);
        const xi = (x + m0 * s0) / (m0 * ap);
        const eta = y / (m0 * ap);
        const delta = [0, (1/2)*n-(2/3)*(n**2)+(37/96)*(n**3), (1/48)*(n**2)+(1/15)*(n**3), (17/480)*(n**3)];
        let xip = xi, etap = eta;
        for(let j=1; j<=3; j++) {
            xip -= delta[j] * Math.sin(2*j*xi) * Math.cosh(2*j*eta);
            etap -= delta[j] * Math.cos(2*j*xi) * Math.sinh(2*j*eta);
        }
        const chi = Math.asin(Math.sin(xip) / Math.cosh(etap));
        const phi = chi + ( (e2/2) + (5/24)*(e2**2) + (e2**3)/12 )*Math.sin(2*chi) 
                    + ( (7/48)*(e2**2) + (29/240)*(e2**3) )*Math.sin(4*chi) 
                    + ( (7/120)*(e2**3) )*Math.sin(6*chi);
        const lam = lam0 + Math.atan(Math.sinh(etap) / Math.cos(xip));
        return [phi * 180 / Math.PI, lam * 180 / Math.PI];
    }

    function showMap(fitBounds = true) {
        if (!currentRaw) return alert("位置情報を取得してください");
        document.getElementById('map').style.display = 'block';
        const sysId = document.getElementById('systemSelect').value;
        const tx = parseFloat(document.getElementById('targetX').value);
        const ty = parseFloat(document.getElementById('targetY').value);
        let targetLatLng = (!isNaN(tx) && !isNaN(ty)) ? reverseConvert(tx, ty, sysId) : null;

        if (!map) {
            map = L.map('map');
            L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', { attribution: "地理院地図" }).addTo(map);
            currentMarker = L.marker([currentRaw.lat, currentRaw.lon]).addTo(map).bindPopup("現在地");
        } else {
            currentMarker.setLatLng([currentRaw.lat, currentRaw.lon]);
        }

        // 目標マーカーの処理
        if (targetLatLng) {
            if (!targetMarker) {
                targetMarker = L.marker(targetLatLng, {
                    icon: L.icon({
                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                        iconSize: [25, 41], iconAnchor: [12, 41]
                    })
                }).addTo(map).bindPopup("目標");
            } else { targetMarker.setLatLng(targetLatLng); }
        }

        // 軌跡ラインの描画処理
        const trace = JSON.parse(localStorage.getItem(STORAGE_KEY_TRACE) || "[]");
        if (trace.length > 0) {
            if (tracePolyline) {
                tracePolyline.setLatLngs(trace);
            } else {
                tracePolyline = L.polyline(trace, {color: 'blue', weight: 4, opacity: 0.6}).addTo(map);
            }
        }

        // 地図の範囲調整（fitBoundsがtrueの場合のみ）
        if (fitBounds) {
            const boundsGroup = [currentMarker];
            if (targetMarker) boundsGroup.push(targetMarker);
            // 軌跡も含めて全体を表示したい場合は以下を有効化
            // if (tracePolyline) boundsGroup.push(tracePolyline); 
            
            const group = L.featureGroup(boundsGroup);
            map.fitBounds(group.getBounds().pad(0.2));
        }
        
        setTimeout(() => map.invalidateSize(), 100);
    }

    // --- イベントリスナー ---
    document.getElementById('btnCompass').addEventListener('click', initCompass);
    // ボタンクリック時の挙動をtoggleTrackingに変更
    document.getElementById('btnGps').addEventListener('click', toggleTracking);
    
    document.getElementById('btnMap').addEventListener('click', () => showMap(true));
    // 消去ボタン
    document.getElementById('btnClearTrace').addEventListener('click', clearTrace);
    
    // 入力連動イベント
    document.getElementById('targetLat').addEventListener('input', syncFromLatLon);
    document.getElementById('targetLon').addEventListener('input', syncFromLatLon);
    document.getElementById('targetX').addEventListener('input', syncFromXY);
    document.getElementById('targetY').addEventListener('input', syncFromXY);
    
    document.getElementById('systemSelect').addEventListener('change', () => { if(currentRaw) getLocation(); });
</script>
</body>
</html>
